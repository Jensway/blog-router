#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
MT-6000 è·¯ç”±å™¨ ShareCenter ç¼–è¯‘éƒ¨ç½²å·¥å…· v2.1
åŠŸèƒ½ï¼š
1. é€‰æ‹©Goæºæ–‡ä»¶å¹¶äº¤å‰ç¼–è¯‘ä¸ºARM64ï¼ˆç¼–è¯‘å‰æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼‰
2. å¤åˆ¶åˆ°éƒ¨ç½²è·¯å¾„å¹¶æ”¹åä¸ºshare-center
3. SSHè¿æ¥è·¯ç”±å™¨å¹¶é‡å¯æœåŠ¡
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import subprocess
import threading
import os
import shutil
import re
import json
from pathlib import Path
from datetime import datetime

# SSHæ”¯æŒ
try:
    import paramiko

    SSH_AVAILABLE = True
except ImportError:
    SSH_AVAILABLE = False

# é…ç½®æ–‡ä»¶è·¯å¾„
CONFIG_FILE = "deploy_config.json"


class ShareCenterDeployTool:
    def __init__(self, root):
        self.root = root
        self.root.title("MT-6000 ShareCenter ç¼–è¯‘éƒ¨ç½²å·¥å…· v2.1")
        self.root.geometry("900x800")
        self.root.resizable(True, True)

        # SSHè¿æ¥å¯¹è±¡
        self.ssh_client = None
        self.ssh_connected = False

        # å˜é‡
        self.go_file_path = tk.StringVar()
        self.output_file_name = tk.StringVar()
        self.publish_path = tk.StringVar()  # å‘å¸ƒè·¯å¾„ï¼ˆGoæ–‡ä»¶ç›®å½•ï¼‰
        self.deploy_path = tk.StringVar(value="Y:\\RouterApp\\ShareCenter")  # éƒ¨ç½²è·¯å¾„

        self.ssh_host = tk.StringVar(value="192.168.8.1")
        self.ssh_port = tk.IntVar(value=22)
        self.ssh_user = tk.StringVar(value="root")
        self.ssh_password = tk.StringVar()
        self.remote_dir = tk.StringVar(value="/tmp/mountd/disk1_part1/RouterApp/ShareCenter")
        self.service_port = tk.IntVar(value=5000)

        # ç¼–è¯‘å‰æ£€æŸ¥é€‰é¡¹
        self.check_before_compile = tk.BooleanVar(value=True)
        self.auto_backup = tk.BooleanVar(value=True)

        # åŠ è½½é…ç½®
        self.load_config()

        self.create_ui()

    def load_config(self):
        """åŠ è½½é…ç½®æ–‡ä»¶"""
        try:
            if os.path.exists(CONFIG_FILE):
                with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                    self.publish_path.set(config.get('publish_path', ''))
                    self.deploy_path.set(config.get('deploy_path', 'Y:\\RouterApp\\ShareCenter'))
                    self.ssh_host.set(config.get('ssh_host', '192.168.8.1'))
                    self.ssh_port.set(config.get('ssh_port', 22))
                    self.ssh_user.set(config.get('ssh_user', 'root'))
                    self.ssh_password.set(config.get('ssh_password', ''))
                    self.remote_dir.set(config.get('remote_dir', '/tmp/mountd/disk1_part1/RouterApp/ShareCenter'))
                    self.service_port.set(config.get('service_port', 5000))
                    self.check_before_compile.set(config.get('check_before_compile', True))
                    self.auto_backup.set(config.get('auto_backup', True))
        except Exception as e:
            print(f"åŠ è½½é…ç½®å¤±è´¥: {e}")

    def save_config(self):
        """ä¿å­˜é…ç½®æ–‡ä»¶"""
        try:
            config = {
                'publish_path': self.publish_path.get(),
                'deploy_path': self.deploy_path.get(),
                'ssh_host': self.ssh_host.get(),
                'ssh_port': self.ssh_port.get(),
                'ssh_user': self.ssh_user.get(),
                'ssh_password': self.ssh_password.get(),
                'remote_dir': self.remote_dir.get(),
                'service_port': self.service_port.get(),
                'check_before_compile': self.check_before_compile.get(),
                'auto_backup': self.auto_backup.get()
            }
            with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(config, f, ensure_ascii=False, indent=2)
            self.log("âœ… é…ç½®å·²ä¿å­˜", "SUCCESS")
        except Exception as e:
            self.log(f"ä¿å­˜é…ç½®å¤±è´¥: {e}", "ERROR")

    def create_ui(self):
        """åˆ›å»ºUIç•Œé¢"""
        # è·¯å¾„è®¾ç½®åŒºåŸŸ
        path_frame = ttk.LabelFrame(self.root, text="ğŸ“ è·¯å¾„è®¾ç½®")
        path_frame.pack(fill=tk.X, padx=10, pady=5)

        # å‘å¸ƒè·¯å¾„
        ttk.Label(path_frame, text="å‘å¸ƒè·¯å¾„:").grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)
        ttk.Entry(path_frame, textvariable=self.publish_path, width=55).grid(row=0, column=1, padx=5, pady=5)
        ttk.Button(path_frame, text="æµè§ˆ...", command=self.browse_publish_path).grid(row=0, column=2, padx=5, pady=5)
        ttk.Label(path_frame, text="(Goæºæ–‡ä»¶åŠç¼–è¯‘è¾“å‡ºç›®å½•)", foreground="gray").grid(row=0, column=3, padx=5, pady=5,
                                                                                       sticky=tk.W)

        # éƒ¨ç½²è·¯å¾„
        ttk.Label(path_frame, text="éƒ¨ç½²è·¯å¾„:").grid(row=1, column=0, padx=5, pady=5, sticky=tk.W)
        ttk.Entry(path_frame, textvariable=self.deploy_path, width=55).grid(row=1, column=1, padx=5, pady=5)
        ttk.Button(path_frame, text="æµè§ˆ...", command=self.browse_deploy_path).grid(row=1, column=2, padx=5, pady=5)
        ttk.Label(path_frame, text="(ç½‘ç»œå…±äº«ç›®å½•)", foreground="gray").grid(row=1, column=3, padx=5, pady=5,
                                                                             sticky=tk.W)

        # ä¿å­˜é…ç½®æŒ‰é’®
        ttk.Button(path_frame, text="ğŸ’¾ ä¿å­˜é…ç½®", command=self.save_config).grid(row=2, column=1, pady=5, sticky=tk.E)

        # æ­¥éª¤é€‰é¡¹å¡
        notebook = ttk.Notebook(self.root)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # ç¬¬1æ­¥ï¼šç¼–è¯‘
        compile_frame = ttk.Frame(notebook)
        notebook.add(compile_frame, text="ğŸ“¦ ç¬¬1æ­¥ï¼šäº¤å‰ç¼–è¯‘")
        self.create_compile_ui(compile_frame)

        # ç¬¬2æ­¥ï¼šæœ¬åœ°éƒ¨ç½²
        local_deploy_frame = ttk.Frame(notebook)
        notebook.add(local_deploy_frame, text="ğŸ“‹ ç¬¬2æ­¥ï¼šæœ¬åœ°éƒ¨ç½²")
        self.create_local_deploy_ui(local_deploy_frame)

        # ç¬¬3æ­¥ï¼šSSHè¿œç¨‹
        ssh_frame = ttk.Frame(notebook)
        notebook.add(ssh_frame, text="ğŸš€ ç¬¬3æ­¥ï¼šSSHé‡å¯")
        self.create_ssh_ui(ssh_frame)

        # ä¸€é”®æ“ä½œ
        quick_frame = ttk.LabelFrame(self.root, text="âš¡ å¿«æ·æ“ä½œ")
        quick_frame.pack(fill=tk.X, padx=10, pady=5)

        ttk.Button(quick_frame, text="ğŸ”„ ä¸€é”®å…¨æµç¨‹ï¼ˆç¼–è¯‘â†’éƒ¨ç½²â†’é‡å¯ï¼‰",
                   command=self.one_click_all, width=40).pack(pady=10)

        # æ—¥å¿—åŒºåŸŸ
        log_frame = ttk.LabelFrame(self.root, text="ğŸ“‹ æ‰§è¡Œæ—¥å¿—")
        log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        self.log_text = scrolledtext.ScrolledText(log_frame, height=10, font=("Consolas", 9))
        self.log_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # é…ç½®æ—¥å¿—é¢œè‰²æ ‡ç­¾
        self.log_text.tag_configure("SUCCESS", foreground="green")
        self.log_text.tag_configure("ERROR", foreground="red")
        self.log_text.tag_configure("WARNING", foreground="orange")
        self.log_text.tag_configure("INFO", foreground="black")

        ttk.Button(log_frame, text="æ¸…é™¤æ—¥å¿—", command=self.clear_log).pack(pady=5)

    def create_compile_ui(self, parent):
        """åˆ›å»ºç¼–è¯‘ç•Œé¢"""
        # æ–‡ä»¶é€‰æ‹©
        file_frame = ttk.LabelFrame(parent, text="æºæ–‡ä»¶é€‰æ‹©")
        file_frame.pack(fill=tk.X, padx=10, pady=10)

        ttk.Label(file_frame, text="Goæºæ–‡ä»¶:").grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)
        ttk.Entry(file_frame, textvariable=self.go_file_path, width=50).grid(row=0, column=1, padx=5, pady=5)
        ttk.Button(file_frame, text="é€‰æ‹©æ–‡ä»¶...", command=self.browse_go_file).grid(row=0, column=2, padx=5, pady=5)

        ttk.Label(file_frame, text="è¾“å‡ºæ–‡ä»¶å:").grid(row=1, column=0, padx=5, pady=5, sticky=tk.W)
        ttk.Entry(file_frame, textvariable=self.output_file_name, width=50).grid(row=1, column=1, padx=5, pady=5)
        ttk.Button(file_frame, text="æ£€æŸ¥æ–‡ä»¶", command=self.check_output_file).grid(row=1, column=2, padx=5, pady=5)

        # è¾“å‡ºæ–‡ä»¶çŠ¶æ€
        self.output_file_status = ttk.Label(file_frame, text="", foreground="gray")
        self.output_file_status.grid(row=2, column=1, columnspan=2, padx=5, pady=2, sticky=tk.W)

        # ç¼–è¯‘é€‰é¡¹
        option_frame = ttk.LabelFrame(parent, text="ç¼–è¯‘é€‰é¡¹")
        option_frame.pack(fill=tk.X, padx=10, pady=10)

        # é€‰é¡¹å¤é€‰æ¡†
        ttk.Checkbutton(option_frame, text="ç¼–è¯‘å‰æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨",
                        variable=self.check_before_compile).grid(row=0, column=0, padx=10, pady=5, sticky=tk.W)
        ttk.Checkbutton(option_frame, text="è¦†ç›–å‰è‡ªåŠ¨å¤‡ä»½",
                        variable=self.auto_backup).grid(row=0, column=1, padx=10, pady=5, sticky=tk.W)

        # ç¼–è¯‘å‚æ•°è¯´æ˜
        info_text = "ç¼–è¯‘å‚æ•°: GOOS=linux  GOARCH=arm64  CGO_ENABLED=0  -ldflags=\"-s -w\""
        ttk.Label(option_frame, text=info_text, foreground="gray").grid(row=1, column=0, columnspan=2, padx=10, pady=5,
                                                                        sticky=tk.W)

        # ç¼–è¯‘æŒ‰é’®
        btn_frame = ttk.Frame(parent)
        btn_frame.pack(pady=20)

        self.compile_btn = ttk.Button(btn_frame, text="ğŸ”¨ å¼€å§‹ç¼–è¯‘", command=self.start_compile, width=20)
        self.compile_btn.pack(side=tk.LEFT, padx=10)

        self.compile_status = ttk.Label(btn_frame, text="", foreground="gray")
        self.compile_status.pack(side=tk.LEFT, padx=10)

    def create_local_deploy_ui(self, parent):
        """åˆ›å»ºæœ¬åœ°éƒ¨ç½²ç•Œé¢"""
        info_frame = ttk.LabelFrame(parent, text="éƒ¨ç½²è¯´æ˜")
        info_frame.pack(fill=tk.X, padx=10, pady=10)

        info_text = """
        æœ¬æ­¥éª¤å°†æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š
        1. å°†ç¼–è¯‘ç”Ÿæˆçš„æ–‡ä»¶ï¼ˆå¦‚ share-center-mt6000_v5.0_arm64ï¼‰
        2. å¤åˆ¶åˆ°éƒ¨ç½²è·¯å¾„ï¼ˆå¦‚ Y:\\RouterApp\\ShareCenterï¼‰
        3. å¹¶é‡å‘½åä¸º share-centerï¼ˆæ›¿æ¢åŸæœ‰æ–‡ä»¶ï¼‰

        æ³¨æ„ï¼šéƒ¨ç½²è·¯å¾„é€šå¸¸æ˜¯è·¯ç”±å™¨çš„ç½‘ç»œå…±äº«ç›®å½•
        """
        ttk.Label(info_frame, text=info_text, justify=tk.LEFT).pack(padx=10, pady=5)

        # æ–‡ä»¶ä¿¡æ¯
        file_frame = ttk.LabelFrame(parent, text="æ–‡ä»¶ä¿¡æ¯")
        file_frame.pack(fill=tk.X, padx=10, pady=10)

        self.source_file_label = ttk.Label(file_frame, text="æºæ–‡ä»¶: (è¯·å…ˆå®Œæˆç¼–è¯‘)")
        self.source_file_label.pack(anchor=tk.W, padx=10, pady=5)

        self.target_file_label = ttk.Label(file_frame, text="ç›®æ ‡æ–‡ä»¶: (ç­‰å¾…éƒ¨ç½²)")
        self.target_file_label.pack(anchor=tk.W, padx=10, pady=5)

        self.deploy_file_status = ttk.Label(file_frame, text="", foreground="gray")
        self.deploy_file_status.pack(anchor=tk.W, padx=10, pady=5)

        # éƒ¨ç½²æŒ‰é’®
        btn_frame = ttk.Frame(parent)
        btn_frame.pack(pady=20)

        ttk.Button(btn_frame, text="ğŸ” æ£€æŸ¥æ–‡ä»¶", command=self.check_deploy_files, width=15).pack(side=tk.LEFT, padx=5)
        self.deploy_btn = ttk.Button(btn_frame, text="ğŸ“‹ å¤åˆ¶å¹¶é‡å‘½å", command=self.local_deploy, width=20)
        self.deploy_btn.pack(side=tk.LEFT, padx=10)

        self.deploy_status = ttk.Label(btn_frame, text="", foreground="gray")
        self.deploy_status.pack(side=tk.LEFT, padx=10)

    def create_ssh_ui(self, parent):
        """åˆ›å»ºSSHç•Œé¢"""
        # SSHè¿æ¥è®¾ç½®
        ssh_frame = ttk.LabelFrame(parent, text="SSHè¿æ¥è®¾ç½®")
        ssh_frame.pack(fill=tk.X, padx=10, pady=10)

        ttk.Label(ssh_frame, text="ä¸»æœºIP:").grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)
        ttk.Entry(ssh_frame, textvariable=self.ssh_host, width=20).grid(row=0, column=1, padx=5, pady=5)

        ttk.Label(ssh_frame, text="ç«¯å£:").grid(row=0, column=2, padx=5, pady=5, sticky=tk.W)
        ttk.Entry(ssh_frame, textvariable=self.ssh_port, width=10).grid(row=0, column=3, padx=5, pady=5)

        ttk.Label(ssh_frame, text="ç”¨æˆ·å:").grid(row=1, column=0, padx=5, pady=5, sticky=tk.W)
        ttk.Entry(ssh_frame, textvariable=self.ssh_user, width=20).grid(row=1, column=1, padx=5, pady=5)

        ttk.Label(ssh_frame, text="å¯†ç :").grid(row=1, column=2, padx=5, pady=5, sticky=tk.W)
        ttk.Entry(ssh_frame, textvariable=self.ssh_password, width=20, show="*").grid(row=1, column=3, padx=5, pady=5)

        # è¿æ¥æµ‹è¯•
        conn_frame = ttk.Frame(ssh_frame)
        conn_frame.grid(row=2, column=0, columnspan=4, pady=10)

        self.connect_btn = ttk.Button(conn_frame, text="ğŸ”— æµ‹è¯•è¿æ¥", command=self.test_ssh_connection)
        self.connect_btn.pack(side=tk.LEFT, padx=5)

        self.ssh_status = ttk.Label(conn_frame, text="æœªè¿æ¥", foreground="gray")
        self.ssh_status.pack(side=tk.LEFT, padx=10)

        if not SSH_AVAILABLE:
            ttk.Label(conn_frame, text="âš ï¸ è¯·å®‰è£…: pip install paramiko", foreground="red").pack(side=tk.LEFT, padx=10)

        # è¿œç¨‹è®¾ç½®
        remote_frame = ttk.LabelFrame(parent, text="è¿œç¨‹æœåŠ¡è®¾ç½®")
        remote_frame.pack(fill=tk.X, padx=10, pady=10)

        ttk.Label(remote_frame, text="è¿œç¨‹ç›®å½•:").grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)
        ttk.Entry(remote_frame, textvariable=self.remote_dir, width=50).grid(row=0, column=1, padx=5, pady=5)

        ttk.Label(remote_frame, text="æœåŠ¡ç«¯å£:").grid(row=1, column=0, padx=5, pady=5, sticky=tk.W)
        ttk.Entry(remote_frame, textvariable=self.service_port, width=10).grid(row=1, column=1, padx=5, pady=5,
                                                                               sticky=tk.W)

        # æ‰§è¡Œå‘½ä»¤è¯´æ˜
        cmd_frame = ttk.LabelFrame(parent, text="å°†æ‰§è¡Œçš„å‘½ä»¤")
        cmd_frame.pack(fill=tk.X, padx=10, pady=10)

        cmd_text = """killall share-center
cd /tmp/mountd/disk1_part1/RouterApp/ShareCenter
chmod +x ./share-center
./share-center -port 5000 -dir . &
ps | grep share-center"""
        ttk.Label(cmd_frame, text=cmd_text, justify=tk.LEFT, font=("Consolas", 9)).pack(padx=10, pady=5)

        # æ“ä½œæŒ‰é’®
        action_frame = ttk.Frame(parent)
        action_frame.pack(pady=10)

        ttk.Button(action_frame, text="ğŸ›‘ åœæ­¢æœåŠ¡", command=self.stop_service, width=15).pack(side=tk.LEFT, padx=5)
        ttk.Button(action_frame, text="â–¶ï¸ å¯åŠ¨æœåŠ¡", command=self.start_service, width=15).pack(side=tk.LEFT, padx=5)
        ttk.Button(action_frame, text="ğŸ”„ é‡å¯æœåŠ¡", command=self.restart_service, width=15).pack(side=tk.LEFT, padx=5)
        ttk.Button(action_frame, text="ğŸ“Š æŸ¥çœ‹çŠ¶æ€", command=self.check_status, width=15).pack(side=tk.LEFT, padx=5)

    def browse_publish_path(self):
        """æµè§ˆå‘å¸ƒè·¯å¾„"""
        path = filedialog.askdirectory(title="é€‰æ‹©å‘å¸ƒè·¯å¾„ï¼ˆGoæºæ–‡ä»¶ç›®å½•ï¼‰")
        if path:
            self.publish_path.set(path)

    def browse_deploy_path(self):
        """æµè§ˆéƒ¨ç½²è·¯å¾„"""
        path = filedialog.askdirectory(title="é€‰æ‹©éƒ¨ç½²è·¯å¾„ï¼ˆç½‘ç»œå…±äº«ç›®å½•ï¼‰")
        if path:
            self.deploy_path.set(path)

    def browse_go_file(self):
        """æµè§ˆé€‰æ‹©Goæºæ–‡ä»¶"""
        initial_dir = self.publish_path.get() if self.publish_path.get() else None
        file_path = filedialog.askopenfilename(
            title="é€‰æ‹©Goæºæ–‡ä»¶",
            initialdir=initial_dir,
            filetypes=[("Goæºæ–‡ä»¶", "*.go"), ("æ‰€æœ‰æ–‡ä»¶", "*.*")]
        )
        if file_path:
            self.go_file_path.set(file_path)
            # è‡ªåŠ¨è®¾ç½®å‘å¸ƒè·¯å¾„
            self.publish_path.set(str(Path(file_path).parent))
            # ç”Ÿæˆè¾“å‡ºæ–‡ä»¶å
            self.generate_output_name()
            # æ£€æŸ¥è¾“å‡ºæ–‡ä»¶æ˜¯å¦å­˜åœ¨
            self.check_output_file()

    def generate_output_name(self):
        """è‡ªåŠ¨ç”Ÿæˆè¾“å‡ºæ–‡ä»¶å"""
        go_file = self.go_file_path.get()
        if go_file:
            base_name = Path(go_file).stem  # share-center_v5_0

            # _v5_0 -> _v5.0
            new_name = re.sub(r'_v(\d+)_(\d+)', r'_v\1.\2', base_name)

            # æ·»åŠ mt6000å’Œarm64åç¼€
            if "mt6000" not in new_name.lower():
                new_name = new_name.replace("share-center", "share-center-mt6000", 1)

            output_name = f"{new_name}_arm64"
            self.output_file_name.set(output_name)

            # æ›´æ–°æœ¬åœ°éƒ¨ç½²ç•Œé¢çš„æ–‡ä»¶ä¿¡æ¯
            self.update_deploy_file_info()

    def check_output_file(self):
        """æ£€æŸ¥è¾“å‡ºæ–‡ä»¶æ˜¯å¦å­˜åœ¨"""
        output_name = self.output_file_name.get()
        publish_path = self.publish_path.get()

        if not output_name or not publish_path:
            self.output_file_status.config(text="è¯·å…ˆé€‰æ‹©Goæºæ–‡ä»¶", foreground="gray")
            return False

        output_path = os.path.join(publish_path, output_name)

        if os.path.exists(output_path):
            file_size = os.path.getsize(output_path)
            mod_time = datetime.fromtimestamp(os.path.getmtime(output_path))
            status_text = f"âš ï¸ æ–‡ä»¶å·²å­˜åœ¨: {file_size / 1024 / 1024:.2f}MB, ä¿®æ”¹æ—¶é—´: {mod_time.strftime('%Y-%m-%d %H:%M:%S')}"
            self.output_file_status.config(text=status_text, foreground="orange")
            self.log(f"æ£€æµ‹åˆ°å·²å­˜åœ¨çš„è¾“å‡ºæ–‡ä»¶: {output_path}", "WARNING")
            return True
        else:
            self.output_file_status.config(text="âœ… è¾“å‡ºæ–‡ä»¶ä¸å­˜åœ¨ï¼Œå¯ä»¥ç¼–è¯‘", foreground="green")
            return False

    def check_deploy_files(self):
        """æ£€æŸ¥éƒ¨ç½²ç›¸å…³æ–‡ä»¶"""
        output_name = self.output_file_name.get()
        publish_path = self.publish_path.get()
        deploy_path = self.deploy_path.get()

        status_lines = []

        # æ£€æŸ¥æºæ–‡ä»¶
        if output_name and publish_path:
            source_file = os.path.join(publish_path, output_name)
            if os.path.exists(source_file):
                file_size = os.path.getsize(source_file)
                status_lines.append(f"âœ… æºæ–‡ä»¶å­˜åœ¨: {file_size / 1024 / 1024:.2f}MB")
            else:
                status_lines.append("âŒ æºæ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¯·å…ˆç¼–è¯‘")

        # æ£€æŸ¥ç›®æ ‡æ–‡ä»¶
        if deploy_path:
            target_file = os.path.join(deploy_path, "share-center")
            if os.path.exists(target_file):
                file_size = os.path.getsize(target_file)
                mod_time = datetime.fromtimestamp(os.path.getmtime(target_file))
                status_lines.append(
                    f"âš ï¸ ç›®æ ‡æ–‡ä»¶å·²å­˜åœ¨: {file_size / 1024 / 1024:.2f}MB, {mod_time.strftime('%m-%d %H:%M')}")
            else:
                status_lines.append("âœ… ç›®æ ‡ä½ç½®æ— æ–‡ä»¶")

        self.deploy_file_status.config(text="\n".join(status_lines), foreground="black")
        self.update_deploy_file_info()

    def update_deploy_file_info(self):
        """æ›´æ–°éƒ¨ç½²æ–‡ä»¶ä¿¡æ¯æ˜¾ç¤º"""
        output_name = self.output_file_name.get()
        publish_path = self.publish_path.get()
        deploy_path = self.deploy_path.get()

        if output_name and publish_path:
            source = os.path.join(publish_path, output_name)
            self.source_file_label.config(text=f"æºæ–‡ä»¶: {source}")

        if deploy_path:
            target = os.path.join(deploy_path, "share-center")
            self.target_file_label.config(text=f"ç›®æ ‡æ–‡ä»¶: {target}")

    def log(self, message, level="INFO"):
        """æ·»åŠ æ—¥å¿—"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_line = f"[{timestamp}] [{level}] {message}\n"

        self.log_text.insert(tk.END, log_line, level)
        self.log_text.see(tk.END)
        self.root.update()

    def clear_log(self):
        """æ¸…é™¤æ—¥å¿—"""
        self.log_text.delete(1.0, tk.END)

    def start_compile(self):
        """å¼€å§‹ç¼–è¯‘"""
        go_file = self.go_file_path.get()
        output_name = self.output_file_name.get()
        publish_path = self.publish_path.get()

        if not go_file:
            messagebox.showerror("é”™è¯¯", "è¯·é€‰æ‹©Goæºæ–‡ä»¶")
            return

        if not output_name:
            messagebox.showerror("é”™è¯¯", "è¯·æŒ‡å®šè¾“å‡ºæ–‡ä»¶å")
            return

        if not os.path.exists(go_file):
            messagebox.showerror("é”™è¯¯", f"æºæ–‡ä»¶ä¸å­˜åœ¨: {go_file}")
            return

        output_path = os.path.join(publish_path, output_name)

        # æ£€æŸ¥è¾“å‡ºæ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if self.check_before_compile.get() and os.path.exists(output_path):
            file_size = os.path.getsize(output_path)
            mod_time = datetime.fromtimestamp(os.path.getmtime(output_path))

            msg = f"è¾“å‡ºæ–‡ä»¶å·²å­˜åœ¨:\n\n"
            msg += f"æ–‡ä»¶: {output_name}\n"
            msg += f"å¤§å°: {file_size / 1024 / 1024:.2f} MB\n"
            msg += f"ä¿®æ”¹æ—¶é—´: {mod_time.strftime('%Y-%m-%d %H:%M:%S')}\n\n"
            msg += "æ˜¯å¦è¦†ç›–ï¼Ÿ"

            if not messagebox.askyesno("æ–‡ä»¶å·²å­˜åœ¨", msg, icon='warning'):
                self.log("ç”¨æˆ·å–æ¶ˆç¼–è¯‘ï¼ˆæ–‡ä»¶å·²å­˜åœ¨ï¼‰", "WARNING")
                return

            # è‡ªåŠ¨å¤‡ä»½
            if self.auto_backup.get():
                backup_name = f"{output_name}.bak.{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                backup_path = os.path.join(publish_path, backup_name)
                try:
                    shutil.copy2(output_path, backup_path)
                    self.log(f"å·²å¤‡ä»½åŸæ–‡ä»¶: {backup_name}", "WARNING")
                except Exception as e:
                    self.log(f"å¤‡ä»½å¤±è´¥: {e}", "ERROR")

        self.compile_btn.config(state=tk.DISABLED)
        self.compile_status.config(text="ç¼–è¯‘ä¸­...", foreground="blue")

        # åœ¨åå°çº¿ç¨‹æ‰§è¡Œç¼–è¯‘
        thread = threading.Thread(target=self._do_compile, args=(go_file, output_name, publish_path))
        thread.daemon = True
        thread.start()

    def _do_compile(self, go_file, output_name, publish_path):
        """æ‰§è¡Œç¼–è¯‘ï¼ˆåå°çº¿ç¨‹ï¼‰"""
        try:
            self.log("=" * 50)
            self.log("ğŸ”¨ å¼€å§‹äº¤å‰ç¼–è¯‘...")
            self.log(f"æºæ–‡ä»¶: {go_file}")
            self.log(f"è¾“å‡ºæ–‡ä»¶: {output_name}")

            output_path = os.path.join(publish_path, output_name)

            # è®¾ç½®ç¯å¢ƒå˜é‡
            env = os.environ.copy()
            env["GOOS"] = "linux"
            env["GOARCH"] = "arm64"
            env["CGO_ENABLED"] = "0"

            self.log("ç¯å¢ƒå˜é‡: GOOS=linux, GOARCH=arm64, CGO_ENABLED=0")

            # æ„å»ºå‘½ä»¤
            cmd = [
                "go", "build",
                "-ldflags=-s -w",
                "-o", output_path,
                go_file
            ]

            self.log(f"æ‰§è¡Œå‘½ä»¤: {' '.join(cmd)}")

            # æ‰§è¡Œç¼–è¯‘
            process = subprocess.Popen(
                cmd,
                env=env,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=publish_path
            )

            stdout, stderr = process.communicate()

            if process.returncode == 0:
                if os.path.exists(output_path):
                    file_size = os.path.getsize(output_path)
                    self.log(f"âœ… ç¼–è¯‘æˆåŠŸ!", "SUCCESS")
                    self.log(f"è¾“å‡ºæ–‡ä»¶: {output_path}", "SUCCESS")
                    self.log(f"æ–‡ä»¶å¤§å°: {file_size / 1024 / 1024:.2f} MB", "SUCCESS")

                    self.root.after(0, lambda: self.compile_status.config(text="âœ… ç¼–è¯‘æˆåŠŸ", foreground="green"))
                    self.root.after(0, self.update_deploy_file_info)
                    self.root.after(0, self.check_output_file)
                else:
                    self.log("âŒ ç¼–è¯‘å¤±è´¥ï¼šè¾“å‡ºæ–‡ä»¶æœªç”Ÿæˆ", "ERROR")
                    self.root.after(0, lambda: self.compile_status.config(text="âŒ å¤±è´¥", foreground="red"))
            else:
                error_msg = stderr.decode("utf-8", errors="ignore")
                self.log(f"âŒ ç¼–è¯‘å¤±è´¥: {error_msg}", "ERROR")
                self.root.after(0, lambda: self.compile_status.config(text="âŒ å¤±è´¥", foreground="red"))

        except Exception as e:
            self.log(f"âŒ ç¼–è¯‘å¼‚å¸¸: {str(e)}", "ERROR")
            self.root.after(0, lambda: self.compile_status.config(text="âŒ å¼‚å¸¸", foreground="red"))
        finally:
            self.root.after(0, lambda: self.compile_btn.config(state=tk.NORMAL))

    def local_deploy(self):
        """æœ¬åœ°éƒ¨ç½² - å¤åˆ¶å¹¶é‡å‘½åæ–‡ä»¶ï¼ˆæ”¯æŒWebDAVï¼‰"""
        output_name = self.output_file_name.get()
        publish_path = self.publish_path.get()
        deploy_path = self.deploy_path.get()

        if not output_name or not publish_path:
            messagebox.showerror("é”™è¯¯", "è¯·å…ˆå®Œæˆç¼–è¯‘æ­¥éª¤")
            return

        if not deploy_path:
            messagebox.showerror("é”™è¯¯", "è¯·è®¾ç½®éƒ¨ç½²è·¯å¾„")
            return

        source_file = os.path.join(publish_path, output_name)
        target_file = os.path.join(deploy_path, "share-center")

        if not os.path.exists(source_file):
            messagebox.showerror("é”™è¯¯", f"æºæ–‡ä»¶ä¸å­˜åœ¨:\n{source_file}\n\nè¯·å…ˆå®Œæˆç¼–è¯‘")
            return

        if not os.path.exists(deploy_path):
            messagebox.showerror("é”™è¯¯", f"éƒ¨ç½²è·¯å¾„ä¸å­˜åœ¨:\n{deploy_path}")
            return

        source_size = os.path.getsize(source_file)

        try:
            self.log("=" * 50)
            self.log("ğŸ“‹ å¼€å§‹æœ¬åœ°éƒ¨ç½²...")
            self.log(f"æºæ–‡ä»¶: {source_file}")
            self.log(f"ç›®æ ‡æ–‡ä»¶: {target_file}")
            self.log(f"æºæ–‡ä»¶å¤§å°: {source_size / 1024 / 1024:.2f} MB")

            # å¤‡ä»½åŸæ–‡ä»¶
            if os.path.exists(target_file) and self.auto_backup.get():
                backup_name = f"share-center.bak.{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                backup_file = os.path.join(deploy_path, backup_name)
                try:
                    shutil.copy2(target_file, backup_file)
                    self.log(f"å·²å¤‡ä»½åŸæ–‡ä»¶: {backup_name}", "WARNING")
                except:
                    pass  # å¿½ç•¥å¤‡ä»½é”™è¯¯

            # å¤åˆ¶æ–‡ä»¶ï¼ˆå¤„ç†WebDAVè¯¯æŠ¥ï¼‰
            try:
                shutil.copy2(source_file, target_file)
            except OSError as e:
                # WebDAV 1237/121 é”™è¯¯é€šå¸¸æ˜¯è¯¯æŠ¥
                if e.winerror in (1237, 121):
                    self.log(f"WebDAVè¿”å›é”™è¯¯ç {e.winerror}ï¼ˆé€šå¸¸æ˜¯è¯¯æŠ¥ï¼‰ï¼ŒéªŒè¯ä¸­...", "WARNING")
                else:
                    raise

            # ç­‰å¾…WebDAVåŒæ­¥
            import time
            time.sleep(0.5)

            # éªŒè¯
            if os.path.exists(target_file):
                target_size = os.path.getsize(target_file)
                if abs(target_size - source_size) < 1024:
                    self.log(f"âœ… éƒ¨ç½²æˆåŠŸ! ({target_size / 1024 / 1024:.2f} MB)", "SUCCESS")
                    self.deploy_status.config(text="âœ… éƒ¨ç½²æˆåŠŸ", foreground="green")
                    messagebox.showinfo("æˆåŠŸ", f"æœ¬åœ°éƒ¨ç½²æˆåŠŸ!\n\n{target_file}")
                else:
                    self.log(f"âš ï¸ æ–‡ä»¶å¤§å°ä¸åŒ¹é…", "WARNING")
                    self.deploy_status.config(text="âš ï¸ éœ€æ£€æŸ¥", foreground="orange")
            else:
                self.log("âŒ ç›®æ ‡æ–‡ä»¶æœªåˆ›å»º", "ERROR")
                self.deploy_status.config(text="âŒ å¤±è´¥", foreground="red")

        except Exception as e:
            self.log(f"âŒ éƒ¨ç½²å¼‚å¸¸: {str(e)}", "ERROR")
            self.deploy_status.config(text="âŒ å¼‚å¸¸", foreground="red")
            messagebox.showerror("éƒ¨ç½²å¤±è´¥", str(e))

    def get_ssh_client(self):
        """è·å–SSHè¿æ¥"""
        if not SSH_AVAILABLE:
            messagebox.showerror("é”™è¯¯", "è¯·å…ˆå®‰è£…paramikoåº“:\npip install paramiko")
            return None

        try:
            if self.ssh_client and self.ssh_connected:
                try:
                    self.ssh_client.exec_command("echo test", timeout=5)
                    return self.ssh_client
                except:
                    self.ssh_connected = False

            self.log(f"è¿æ¥SSH: {self.ssh_user.get()}@{self.ssh_host.get()}:{self.ssh_port.get()}")

            client = paramiko.SSHClient()
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            client.connect(
                hostname=self.ssh_host.get(),
                port=self.ssh_port.get(),
                username=self.ssh_user.get(),
                password=self.ssh_password.get(),
                timeout=10
            )

            self.ssh_client = client
            self.ssh_connected = True
            self.ssh_status.config(text="âœ… å·²è¿æ¥", foreground="green")
            self.log("SSHè¿æ¥æˆåŠŸ", "SUCCESS")
            return client

        except Exception as e:
            self.log(f"SSHè¿æ¥å¤±è´¥: {str(e)}", "ERROR")
            self.ssh_status.config(text="âŒ è¿æ¥å¤±è´¥", foreground="red")
            messagebox.showerror("SSHé”™è¯¯", f"è¿æ¥å¤±è´¥:\n{str(e)}")
            return None

    def test_ssh_connection(self):
        """æµ‹è¯•SSHè¿æ¥"""
        self.log("æµ‹è¯•SSHè¿æ¥...")
        client = self.get_ssh_client()
        if client:
            try:
                stdin, stdout, stderr = client.exec_command("uname -a")
                output = stdout.read().decode("utf-8")
                self.log(f"ç³»ç»Ÿä¿¡æ¯: {output.strip()}", "SUCCESS")
                messagebox.showinfo("è¿æ¥æˆåŠŸ", f"SSHè¿æ¥æˆåŠŸ!\n\nç³»ç»Ÿä¿¡æ¯:\n{output}")
            except Exception as e:
                self.log(f"å‘½ä»¤æ‰§è¡Œå¤±è´¥: {str(e)}", "ERROR")

    def exec_ssh_command(self, command, show_output=True):
        """æ‰§è¡ŒSSHå‘½ä»¤"""
        client = self.get_ssh_client()
        if not client:
            return None

        try:
            self.log(f"$ {command}")
            stdin, stdout, stderr = client.exec_command(command)

            output = stdout.read().decode("utf-8")
            error = stderr.read().decode("utf-8")

            if show_output:
                if output:
                    for line in output.strip().split("\n"):
                        if line:
                            self.log(f"  {line}")
                if error:
                    for line in error.strip().split("\n"):
                        if line:
                            self.log(f"  ! {line}", "WARNING")

            return output, error

        except Exception as e:
            self.log(f"å‘½ä»¤æ‰§è¡Œå¤±è´¥: {str(e)}", "ERROR")
            return None

    def stop_service(self):
        """åœæ­¢æœåŠ¡"""
        self.log("=" * 50)
        self.log("ğŸ›‘ åœæ­¢ShareCenteræœåŠ¡...")
        self.exec_ssh_command("killall share-center 2>/dev/null || echo 'æœåŠ¡æœªè¿è¡Œ'")
        self.log("âœ… åœæ­¢å‘½ä»¤å·²æ‰§è¡Œ", "SUCCESS")

    def start_service(self):
        """å¯åŠ¨æœåŠ¡"""
        remote_dir = self.remote_dir.get()
        port = self.service_port.get()

        self.log("=" * 50)
        self.log("â–¶ï¸ å¯åŠ¨ShareCenteræœåŠ¡...")

        # è®¾ç½®æ‰§è¡Œæƒé™
        self.exec_ssh_command(f"chmod +x {remote_dir}/share-center")

        # åå°å¯åŠ¨æœåŠ¡
        cmd = f"cd {remote_dir} && nohup ./share-center -port {port} -dir . > /tmp/share-center.log 2>&1 &"
        self.exec_ssh_command(cmd)

        # ç­‰å¾…å¯åŠ¨
        import time
        time.sleep(1)

        # æ£€æŸ¥çŠ¶æ€
        self.check_status()

    def restart_service(self):
        """é‡å¯æœåŠ¡"""
        self.log("=" * 50)
        self.log("ğŸ”„ é‡å¯ShareCenteræœåŠ¡...")
        self.stop_service()

        import time
        time.sleep(1)

        self.start_service()

    def check_status(self):
        """æ£€æŸ¥æœåŠ¡çŠ¶æ€"""
        self.log("ğŸ“Š æ£€æŸ¥æœåŠ¡çŠ¶æ€...")
        result = self.exec_ssh_command("ps | grep share-center | grep -v grep")

        if result and result[0].strip():
            self.log("âœ… æœåŠ¡æ­£åœ¨è¿è¡Œ", "SUCCESS")
        else:
            self.log("âš ï¸ æœåŠ¡æœªè¿è¡Œ", "WARNING")

    def one_click_all(self):
        """ä¸€é”®å…¨æµç¨‹"""
        if not messagebox.askyesno("ç¡®è®¤",
                                   "æ˜¯å¦æ‰§è¡Œä¸€é”®å…¨æµç¨‹ï¼Ÿ\n\nå°†ä¾æ¬¡æ‰§è¡Œï¼š\n1. äº¤å‰ç¼–è¯‘\n2. æœ¬åœ°éƒ¨ç½²ï¼ˆå¤åˆ¶åˆ°ç½‘ç»œç›®å½•ï¼‰\n3. SSHé‡å¯æœåŠ¡"):
            return

        # éªŒè¯å‚æ•°
        go_file = self.go_file_path.get()
        if not go_file:
            messagebox.showerror("é”™è¯¯", "è¯·å…ˆé€‰æ‹©Goæºæ–‡ä»¶")
            return

        deploy_path = self.deploy_path.get()
        if not deploy_path or not os.path.exists(deploy_path):
            messagebox.showerror("é”™è¯¯", "è¯·è®¾ç½®æœ‰æ•ˆçš„éƒ¨ç½²è·¯å¾„")
            return

        output_name = self.output_file_name.get()
        publish_path = self.publish_path.get()
        output_path = os.path.join(publish_path, output_name)

        # æ£€æŸ¥è¾“å‡ºæ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if self.check_before_compile.get() and os.path.exists(output_path):
            file_size = os.path.getsize(output_path)
            mod_time = datetime.fromtimestamp(os.path.getmtime(output_path))

            msg = f"è¾“å‡ºæ–‡ä»¶å·²å­˜åœ¨:\n\n"
            msg += f"æ–‡ä»¶: {output_name}\n"
            msg += f"å¤§å°: {file_size / 1024 / 1024:.2f} MB\n"
            msg += f"ä¿®æ”¹æ—¶é—´: {mod_time.strftime('%Y-%m-%d %H:%M:%S')}\n\n"
            msg += "æ˜¯å¦è¦†ç›–å¹¶ç»§ç»­ï¼Ÿ"

            if not messagebox.askyesno("æ–‡ä»¶å·²å­˜åœ¨", msg, icon='warning'):
                self.log("ç”¨æˆ·å–æ¶ˆæ“ä½œï¼ˆæ–‡ä»¶å·²å­˜åœ¨ï¼‰", "WARNING")
                return

        # åœ¨åå°æ‰§è¡Œ
        thread = threading.Thread(target=self._do_one_click_all)
        thread.daemon = True
        thread.start()

    def _do_one_click_all(self):
        """æ‰§è¡Œä¸€é”®å…¨æµç¨‹ï¼ˆåå°ï¼‰"""
        try:
            self.log("=" * 50)
            self.log("ğŸš€ å¼€å§‹ä¸€é”®å…¨æµç¨‹éƒ¨ç½²...", "SUCCESS")

            # ç¬¬1æ­¥ï¼šç¼–è¯‘
            go_file = self.go_file_path.get()
            output_name = self.output_file_name.get()
            publish_path = self.publish_path.get()

            self.log("")
            self.log("ã€ç¬¬1æ­¥ã€‘äº¤å‰ç¼–è¯‘")

            output_path = os.path.join(publish_path, output_name)

            # å¤‡ä»½å·²å­˜åœ¨çš„æ–‡ä»¶
            if os.path.exists(output_path) and self.auto_backup.get():
                backup_name = f"{output_name}.bak.{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                shutil.copy2(output_path, os.path.join(publish_path, backup_name))
                self.log(f"å·²å¤‡ä»½: {backup_name}", "WARNING")

            env = os.environ.copy()
            env["GOOS"] = "linux"
            env["GOARCH"] = "arm64"
            env["CGO_ENABLED"] = "0"

            cmd = ["go", "build", "-ldflags=-s -w", "-o", output_path, go_file]
            self.log(f"æ‰§è¡Œ: go build -ldflags=\"-s -w\" -o {output_name} ...")

            process = subprocess.Popen(cmd, env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=publish_path)
            stdout, stderr = process.communicate()

            if process.returncode != 0 or not os.path.exists(output_path):
                error_msg = stderr.decode("utf-8", errors="ignore")
                self.log(f"âŒ ç¼–è¯‘å¤±è´¥: {error_msg}", "ERROR")
                self.root.after(0, lambda: messagebox.showerror("å¤±è´¥", "ç¼–è¯‘å¤±è´¥ï¼Œæµç¨‹ç»ˆæ­¢"))
                return

            file_size = os.path.getsize(output_path)
            self.log(f"âœ… ç¼–è¯‘æˆåŠŸ ({file_size / 1024 / 1024:.2f} MB)", "SUCCESS")

            # ç¬¬2æ­¥ï¼šæœ¬åœ°éƒ¨ç½²
            self.log("")
            self.log("ã€ç¬¬2æ­¥ã€‘æœ¬åœ°éƒ¨ç½²")

            deploy_path = self.deploy_path.get()
            target_file = os.path.join(deploy_path, "share-center")

            if os.path.exists(target_file) and self.auto_backup.get():
                backup_name = f"share-center.bak.{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                shutil.copy2(target_file, os.path.join(deploy_path, backup_name))
                self.log(f"å·²å¤‡ä»½: {backup_name}")

            shutil.copy2(output_path, target_file)
            self.log(f"âœ… å·²å¤åˆ¶åˆ°: {target_file}", "SUCCESS")

            # ç¬¬3æ­¥ï¼šSSHé‡å¯
            self.log("")
            self.log("ã€ç¬¬3æ­¥ã€‘SSHé‡å¯æœåŠ¡")

            client = self.get_ssh_client()
            if not client:
                self.log("âŒ SSHè¿æ¥å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é‡å¯æœåŠ¡", "ERROR")
                self.root.after(0, lambda: messagebox.showwarning("è­¦å‘Š",
                                                                  "ç¼–è¯‘å’Œéƒ¨ç½²æˆåŠŸï¼Œä½†SSHè¿æ¥å¤±è´¥\nè¯·æ‰‹åŠ¨é‡å¯è·¯ç”±å™¨æœåŠ¡"))
                return

            remote_dir = self.remote_dir.get()
            port = self.service_port.get()

            # åœæ­¢
            self.exec_ssh_command("killall share-center 2>/dev/null || true")

            import time
            time.sleep(1)

            # è®¾ç½®æƒé™å¹¶å¯åŠ¨
            self.exec_ssh_command(f"chmod +x {remote_dir}/share-center")
            self.exec_ssh_command(
                f"cd {remote_dir} && nohup ./share-center -port {port} -dir . > /tmp/share-center.log 2>&1 &")

            time.sleep(1)

            # æ£€æŸ¥çŠ¶æ€
            result = self.exec_ssh_command("ps | grep share-center | grep -v grep")

            self.log("")
            self.log("=" * 50)
            if result and result[0].strip():
                self.log("ğŸ‰ ä¸€é”®éƒ¨ç½²å®Œæˆï¼æœåŠ¡å·²å¯åŠ¨", "SUCCESS")
                self.root.after(0, lambda: messagebox.showinfo("æˆåŠŸ", "ä¸€é”®éƒ¨ç½²å®Œæˆï¼\n\næœåŠ¡å·²æˆåŠŸå¯åŠ¨"))
            else:
                self.log("âš ï¸ éƒ¨ç½²å®Œæˆï¼Œä½†æœåŠ¡å¯èƒ½æœªæ­£å¸¸å¯åŠ¨", "WARNING")
                self.root.after(0, lambda: messagebox.showwarning("è­¦å‘Š", "éƒ¨ç½²å®Œæˆï¼Œä½†æœåŠ¡å¯èƒ½æœªæ­£å¸¸å¯åŠ¨\nè¯·æ£€æŸ¥æ—¥å¿—"))

        except Exception as e:
            self.log(f"âŒ ä¸€é”®éƒ¨ç½²å¼‚å¸¸: {str(e)}", "ERROR")
            self.root.after(0, lambda: messagebox.showerror("é”™è¯¯", str(e)))


def main():
    root = tk.Tk()
    app = ShareCenterDeployTool(root)
    root.mainloop()


if __name__ == "__main__":
    main()